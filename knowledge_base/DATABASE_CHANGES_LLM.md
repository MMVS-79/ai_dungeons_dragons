# Database Changes for LLM Integration

## Overview

The LLM integration adds event tracking capabilities to the `logs` table to enable context-aware narrative generation using the Gemini AI service. This allows the game engine to track structured event data and maintain narrative continuity across multiple game events.

## Schema Changes

### Logs Table Enhancement

**File:** `lib/schema/tables/logs.sql`

The `logs` table stores LLM-generated events and their effects for context injection into subsequent prompts. It includes structured event information with these columns:

```sql
CREATE TABLE logs (
    id INT PRIMARY KEY AUTO_INCREMENT,
    campaign_id INT,
    message TEXT NOT NULL,
    event_type VARCHAR(50),
    event_data JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (campaign_id) REFERENCES campaigns(id) ON DELETE SET NULL
)
```

**Event Columns:**

| Column | Type | Purpose |
|--------|------|---------|
| `event_type` | VARCHAR(50) | Categorizes the type of event generated by the LLM |
| `event_data` | JSON | Stores structured stat effects (health, attack, defense changes) |

### Event Types

The `event_type` column uses the following enumeration:

- **NARRATIVE** - Story events with no stat effects
- **COMBAT_ACTION** - Direct combat scenarios
- **ENVIRONMENTAL** - Environmental hazards or benefits
- **ITEM_DROP** - Finding or losing items
- **STAT_MODIFIER** - Direct stat changes (buffs/debuffs)

### Event Data Structure

The `event_data` JSON field stores stat modifications with this structure:

```json
{
  "health": -10,    // Range: -10 to +10
  "attack": -5,     // Range: -5 to +5
  "defense": -5     // Range: -5 to +5
}
```

## Database Setup

The `logs` table is created with `event_type` and `event_data` columns included in the base schema. The database is managed through the rebuild system:

**Automatic Deployment:**

The `lib/rebuild.sh` script runs via cron and automatically:
1. Checksums all schema files in `lib/schema/tables/*.sql`
2. Detects changes and runs `lib/rebuild.sql` if schemas changed
3. Recreates all tables from the source files

**Manual Rebuild:**

To force a database rebuild:

```bash
cd lib
./rebuild.sh --force
```

This will recreate all tables including the `logs` table with the LLM columns.

## Integration Points

### How the Game Engine Uses These Fields

```
Character fights a Dragon
        ↓
LLMService.generateEvent() creates:
{
  event: "The dragon roars and breathes fire!",
  type: "COMBAT_ACTION",
  effects: { health: -8, attack: 0, defense: -2 }
}
        ↓
Save to logs table:
- message = "The dragon roars and breathes fire!"
- event_type = "COMBAT_ACTION"
- event_data = {"health": -8, "attack": 0, "defense": -2}
        ↓
Apply stat changes to character:
- health: 100 - 8 = 92
- attack: 15 + 0 = 15
- defense: 10 - 2 = 8
```

### Context Chaining (Narrative Memory)

When generating new events, the game engine retrieves previous events to provide context:

```sql
-- Fetch last 5 events for narrative continuity
SELECT message, event_type, event_data FROM logs 
WHERE campaign_id = ? 
ORDER BY created_at DESC 
LIMIT 5;
```

These messages are passed to the LLM in `recentEvents` array for coherent storytelling.

## Related Tables

### Campaigns (Parent)

- `id` - Campaign identifier
- Each campaign tracks multiple `logs` entries

### Characters (Stat Storage)

- `health`, `attack`, `defense` - Character stats modified by events in logs
- Stats are updated based on `event_data` effects

### Chats (Conversation Log)

- Separate from logs; stores NPC/LLM conversations
- Logs track game events; Chats track conversations

## Example Queries

### View Recent Events with Effects

```sql
SELECT 
  id,
  campaign_id,
  SUBSTRING(message, 1, 50) AS event_summary,
  event_type,
  JSON_EXTRACT(event_data, '$.health') AS health_effect,
  JSON_EXTRACT(event_data, '$.attack') AS attack_effect,
  JSON_EXTRACT(event_data, '$.defense') AS defense_effect,
  created_at
FROM logs
WHERE campaign_id = ?
ORDER BY created_at DESC
LIMIT 10;
```

### Get Total Stat Changes for a Campaign

```sql
SELECT
  campaign_id,
  SUM(JSON_EXTRACT(event_data, '$.health')) AS total_health_change,
  SUM(JSON_EXTRACT(event_data, '$.attack')) AS total_attack_change,
  SUM(JSON_EXTRACT(event_data, '$.defense')) AS total_defense_change
FROM logs
GROUP BY campaign_id;
```

### Filter by Event Type

```sql
SELECT * FROM logs
WHERE campaign_id = ? AND event_type = 'ITEM_DROP'
ORDER BY created_at DESC;
```

## Backward Compatibility

- Existing log entries have default values and continue to work
- The `message` field remains the primary narrative record
- Old queries querying only `message` are unaffected
- The new columns are optional for read operations

## Future Enhancements

Possible future schema additions:

- **event_tags**: Additional categorization (difficulty, encounter_type)
- **event_chain_id**: Link related sequential events
- **confidence_score**: LLM confidence in the generated event (0-100)
- **player_choice**: Track which choice the player made from event options
- **audio_path**: Reference generated audio/voice lines

## Schema Verification

Verify the schema was applied correctly:

```sql
DESCRIBE logs;
```

Expected output should show:

- `event_type` column (VARCHAR(50))
- `event_data` column (JSON)

## Rollback to Simple Logs

If you need to remove the LLM columns, update `lib/schema/tables/logs.sql` to remove the `event_type` and `event_data` columns, then run:

```bash
cd lib
./rebuild.sh --force
```

**Note:** This will recreate the table and lose all stored data.
