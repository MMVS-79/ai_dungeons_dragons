# Database Changes for LLM Integration

## Overview

The LLM integration adds event tracking capabilities to the `event_history` table to enable context-aware narrative generation using the Gemini AI service. This allows the game engine to track structured event data and maintain narrative continuity across multiple game events.

## Schema Changes

### Event History Table Enhancement

**File:** `lib/schema/tables/event_history.sql`

The `event_history` table stores LLM-generated events and their effects for context injection into subsequent prompts. It has been extended with two new columns to store structured event information:

```sql
CREATE TABLE event_history (
    id INT PRIMARY KEY AUTO_INCREMENT,
    campaign_id INT NOT NULL,
    message TEXT NOT NULL,
    event_type VARCHAR(50),                    -- NEW
    event_data JSON,                           -- NEW
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (campaign_id) REFERENCES campaigns(id) ON DELETE SET NULL
)
```

**New Columns:**

| Column | Type | Purpose |
|--------|------|---------|
| `event_type` | VARCHAR(50) | Categorizes the type of event generated by the LLM |
| `event_data` | JSON | Stores structured stat effects (health, attack, defense changes) |

### Event Types

The `event_type` column uses the following enumeration:

- **NARRATIVE** - Story events with no stat effects
- **COMBAT_ACTION** - Direct combat scenarios
- **ENVIRONMENTAL** - Environmental hazards or benefits
- **ITEM_DROP** - Finding or losing items
- **STAT_MODIFIER** - Direct stat changes (buffs/debuffs)

### Event Data Structure

The `event_data` JSON field stores stat modifications with this structure:

```json
{
  "health": -10,    // Range: -10 to +10
  "attack": -5,     // Range: -5 to +5
  "defense": -5     // Range: -5 to +5
}
```

## Migration Guide

### Migration File

**File:** `lib/schema/migrations/001_add_event_data_to_logs.sql`

This migration adds the new columns to an existing `event_history` table:

```sql
ALTER TABLE event_history 
ADD COLUMN event_type VARCHAR(50) AFTER message,
ADD COLUMN event_data JSON AFTER event_type;
```

**Running the Migration:**

1. Ensure your database is initialized with the base schema
2. Run the migration file:

   ```bash
   mysql -u root -p dnd_game < lib/schema/migrations/001_add_event_data_to_logs.sql
   ```

### Data Migration

Existing log entries are automatically populated with default values:

- `event_type` = `'NARRATIVE'` (neutral, no stat effects)
- `event_data` = `'{"health": 0, "attack": 0, "defense": 0}'` (no changes)

## Integration Points

### How the Game Engine Uses These Fields

```
Character fights a Dragon
        ↓
LLMService.generateEvent() creates:
{
  event: "The dragon roars and breathes fire!",
  type: "COMBAT_ACTION",
  effects: { health: -8, attack: 0, defense: -2 }
}
        ↓
Save to event_history table:
- message = "The dragon roars and breathes fire!"
- event_type = "COMBAT_ACTION"
- event_data = {"health": -8, "attack": 0, "defense": -2}
        ↓
Apply stat changes to character:
- health: 100 - 8 = 92
- attack: 15 + 0 = 15
- defense: 10 - 2 = 8
```

### Context Chaining (Narrative Memory)

When generating new events, the game engine retrieves previous events to provide context:

```sql
-- Fetch last 5 events for narrative continuity
SELECT message FROM event_history 
WHERE campaign_id = ? 
ORDER BY created_at DESC 
LIMIT 5;
```

These messages are passed to the LLM in `recentEvents` array for coherent storytelling.

## Related Tables

### Campaigns (Parent)

- `id` - Campaign identifier
- Each campaign tracks multiple `event_history` entries

### Characters (Stat Storage)

- `health`, `attack`, `defense` - Character stats modified by events in event_history
- Stats are updated based on `event_data` effects

### Chats (Conversation Log)

- Separate from event_history; stores NPC/LLM conversations
- Event history tracks game events; Chats track conversations

## Example Queries

### View Recent Events with Effects

```sql
SELECT 
  id,
  campaign_id,
  SUBSTRING(message, 1, 50) AS event_summary,
  event_type,
  JSON_EXTRACT(event_data, '$.health') AS health_effect,
  JSON_EXTRACT(event_data, '$.attack') AS attack_effect,
  JSON_EXTRACT(event_data, '$.defense') AS defense_effect,
  created_at
FROM event_history
WHERE campaign_id = ?
ORDER BY created_at DESC
LIMIT 10;
```

### Get Total Stat Changes for a Campaign

```sql
SELECT
  campaign_id,
  SUM(JSON_EXTRACT(event_data, '$.health')) AS total_health_change,
  SUM(JSON_EXTRACT(event_data, '$.attack')) AS total_attack_change,
  SUM(JSON_EXTRACT(event_data, '$.defense')) AS total_defense_change
FROM event_history
GROUP BY campaign_id;
```

### Filter by Event Type

```sql
SELECT * FROM event_history
WHERE campaign_id = ? AND event_type = 'ITEM_DROP'
ORDER BY created_at DESC;
```

## Backward Compatibility

- Existing log entries have default values and continue to work
- The `message` field remains the primary narrative record
- Old queries querying only `message` are unaffected
- The new columns are optional for read operations

## Future Enhancements

Possible future schema additions:

- **event_tags**: Additional categorization (difficulty, encounter_type)
- **event_chain_id**: Link related sequential events
- **confidence_score**: LLM confidence in the generated event (0-100)
- **player_choice**: Track which choice the player made from event options
- **audio_path**: Reference generated audio/voice lines

## Rollback Procedure

If needed, revert the migration:

```sql
ALTER TABLE event_history 
DROP COLUMN event_type,
DROP COLUMN event_data;
```

**Note:** This will lose all stored event metadata.

## Testing

Verify the schema was applied correctly:

```sql
DESCRIBE event_history;
```

Expected output should show:

- `event_type` column (VARCHAR(50))
- `event_data` column (JSON)
