name: Vercel Deployment Failure Comment

on:
  # This event is triggered by Vercel's GitHub integration when a deployment status changes.
  deployment_status:

jobs:
  handle-vercel-failure:
    # Only run the job if the deployment state is either 'failure' or 'success' 
    # (to delete the previous failure comment). This saves GitHub Actions minutes.
    if: |
      github.event.deployment_status.state == 'failure' ||
      github.event.deployment_status.state == 'success'
    
    runs-on: ubuntu-latest

    steps:
      - name: Check if deployment is from Vercel
        id: check_vercel
        # Vercel deployments typically use 'vercel.app' in the environment URL.
        run: |
          URL="${{ github.event.deployment_status.environment_url }}"
          if [[ "$URL" == *"vercel.app"* ]]; then
            echo "is_vercel=true" >> $GITHUB_OUTPUT
          else
            echo "is_vercel=false" >> $GITHUB_OUTPUT
          fi

      - name: Get deployment details
        if: steps.check_vercel.outputs.is_vercel == 'true'
        id: get_details
        run: |
          TARGET_URL="${{ github.event.deployment_status.target_url }}"
          ENV_URL="${{ github.event.deployment_status.environment_url }}"
          DEPLOYMENT_STATE="${{ github.event.deployment_status.state }}"
          DEPLOYMENT_ID=""
          
          # FIX: Use refined regex to capture the entire subdomain (the unique deployment slug)
          if [[ "$ENV_URL" =~ ^https://(.+)\.vercel\.app ]]; then
            DEPLOYMENT_ID="${BASH_REMATCH[1]}"
          fi
          
          # Fallback extraction (if primary failed or ID is empty)
          if [ -z "$DEPLOYMENT_ID" ]; then
            DEPLOYMENT_ID=$(echo "$TARGET_URL" | grep -oP '[^/]+$')
          fi
          
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "deployment_url=$TARGET_URL" >> $GITHUB_OUTPUT
          echo "deployment_state=$DEPLOYMENT_STATE" >> $GITHUB_OUTPUT
          
          # Debug output
          echo "Extracted Deployment ID: $DEPLOYMENT_ID"
          echo "Target URL: $TARGET_URL"
          echo "Environment URL: $ENV_URL"

      - name: Fetch Vercel logs (only on failure)
        # Only run if it's a Vercel deployment and the state is failure
        if: steps.check_vercel.outputs.is_vercel == 'true' && steps.get_details.outputs.deployment_state == 'failure'
        id: fetch_logs
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
        run: |
          # Mask the Vercel token to prevent it from appearing in logs
          echo "::add-mask::$VERCEL_TOKEN"
          
          DEPLOYMENT_ID="${{ steps.get_details.outputs.deployment_id }}"

          if [ -z "$DEPLOYMENT_ID" ]; then
            echo "No deployment ID found."
            echo "Deployment failed but the deployment ID was missing." > error_logs.txt
            exit 0
          fi
          
          # üí° FIX: Using the V2 /builds endpoint, which is more reliable for Hobby accounts.
          echo "Fetching logs for deployment: $DEPLOYMENT_ID using /builds endpoint"
          
          RESPONSE=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer $VERCEL_TOKEN" \
            "https://api.vercel.com/v2/deployments/$DEPLOYMENT_ID/builds")
          
          # Extract HTTP status code
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')
          
          echo "API Response Code: $HTTP_CODE"
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "Failed to fetch logs from Vercel API (HTTP $HTTP_CODE) at /builds endpoint." > error_logs.txt
            echo "Please ensure your VERCEL_TOKEN has the necessary permissions." >> error_logs.txt
            exit 0
          fi

          # üí° UPDATED LOGIC for the /builds response structure.
          # Extract all log messages from the last build and filter for error-related keywords.
          if echo "$BODY" | jq -e . >/dev/null 2>&1; then
            ERROR_LOGS=$(echo "$BODY" | jq -r '
              # Take the logs array from the LAST build object in the list
              .[-1].logs? | 
              .[] | 
              # Select logs with error keywords
              select(.text? | strings | test("Error|error|Failed|failed|ERR|Exception|BUILD_ERROR|npm ERR|ERROR")) | 
              .text' 2>/dev/null | head -50)
          else
            ERROR_LOGS=""
          fi

          if [ -z "$ERROR_LOGS" ]; then
            ERROR_LOGS="Deployment failed but no specific error logs were captured via the API. Please check the Vercel dashboard for details."
          fi

          echo "$ERROR_LOGS" > error_logs.txt

      - name: Find PR number associated with the commit
        if: steps.check_vercel.outputs.is_vercel == 'true'
        id: find_pr
        uses: actions/github-script@v7
        with:
          script: |
            // FIX: Safely access the commit SHA to prevent 'Cannot read properties of undefined (reading 'sha')'
            const deployment = context.payload.deployment_status.deployment;
            const sha = deployment ? deployment.sha : null;
            
            if (!sha) {
              console.log('No SHA found in deployment status.');
              // Always return a valid JSON object structure
              return { pr_number: null, commit_sha: null };
            }
            
            console.log(`Looking for PRs associated with commit: ${sha}`);
            
            try {
              const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner: context.repo.owner,
                repo: context.repo.repo,
                commit_sha: sha
              });
              
              // Return both the PR number and the short commit SHA
              if (prs.length > 0) {
                console.log(`Found PR #${prs[0].number}`);
                return { 
                  pr_number: prs[0].number,
                  commit_sha: sha.substring(0, 7)
                };
              }
              
              console.log('No PRs found for this commit');
              return { pr_number: null, commit_sha: sha.substring(0, 7) };
            } catch (error) {
              console.log(`Error finding PR: ${error.message}`);
              return { pr_number: null, commit_sha: sha.substring(0, 7) };
            }

      - name: Post or delete PR comment
        # Only run if it's a Vercel deployment AND we found a PR number
        if: steps.check_vercel.outputs.is_vercel == 'true' && fromJSON(steps.find_pr.outputs.result).pr_number != null
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ fromJSON(steps.find_pr.outputs.result).pr_number }}
          DEPLOYMENT_STATE: ${{ steps.get_details.outputs.deployment_state }}
          DEPLOYMENT_URL: ${{ steps.get_details.outputs.deployment_url }}
          COMMIT_SHA: ${{ fromJSON(steps.find_pr.outputs.result).commit_sha }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            
            // Parse environment variables passed from the YAML context
            const prNumber = parseInt(process.env.PR_NUMBER);
            const deploymentUrl = process.env.DEPLOYMENT_URL;
            const commitSha = process.env.COMMIT_SHA || 'unknown';
            const state = process.env.DEPLOYMENT_STATE;
            
            const commentHeader = '## üö® Vercel Deployment Failed';
            const commentFooter = '<sub>This comment was automatically posted by GitHub Actions when the Vercel deployment failed.</sub>';

            console.log(`Processing ${state} state for PR #${prNumber}`);

            // Find an existing failure comment posted by this bot
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const existing = comments.find(c =>
              c.user.type === 'Bot' && c.body && c.body.includes(commentHeader)
            );

            // --- Failure Logic ---
            if (state === 'failure') {
              const errorLogs = fs.existsSync('error_logs.txt')
                ? fs.readFileSync('error_logs.txt', 'utf8')
                : 'Could not retrieve error logs.'; // Fallback message

              const body = [
                commentHeader,
                '',
                `**Status:** ‚ùå **Failure**`,
                `**Deployment:** [View on Vercel](${deploymentUrl})`,
                `**Commit:** \`${commitSha}\``,
                '',
                '### Error Snippet:',
                '```bash',
                errorLogs,
                '```',
                '',
                '---',
                commentFooter
              ].join('\n');

              if (existing) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existing.id,
                  body
                });
                console.log(`Updated existing failure comment (#${existing.id}) on PR #${prNumber}`);
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body
                });
                console.log(`Posted new failure comment on PR #${prNumber}`);
              }
              return;
            }

            // --- Success Logic (Delete Comment) ---
            if (state === 'success' && existing) {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id
              });
              console.log(`Deleted old failure comment after successful deployment.`);
            }

            